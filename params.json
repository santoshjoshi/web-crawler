{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"## **About the application:**\r\n The application is all about harnessing the capabilities of below components to create a web crawler\tthat can crawl any site. \r\nHere we are mainly interested in getting the pin code of various areas/cities across India from a site called [javataskforce.com](http://javataskforce.com/).\r\n\r\n## **This Application uses:**\r\n\r\n1. Apache CXF:\r\n\r\n    For Making rest/http request to remote site and fetch the page.\r\n\r\n1. JPA/Hibernate with HSQLDB:\r\n\r\n    Using JPA with hibernate to populate the HSQLDB with the information we are interested in \r\n \r\n1. Apache Camel:\r\n\r\n    Coordinating between Apache CXF/JPA, leveraging many task that requires a lot of coding,\t\tcreating routes that states what to do and when to do\r\n\r\n## Overview:\r\nThe Whole application is interconnected by camel routes, which are as follows (all routes are defined in camel-routes.xml)\r\n\r\n* **states-invoke-route**\r\n        1. invoke the crawler sevice to get state\r\n  \t1. parse/process the states obtained\r\n  \t1. put them in another Queue\r\n  \t1. store the states into HSQLDB\r\n\r\n* **districts-invoke-route**\r\n\t1. pool the DB( HsqlDb) and get the State with some particular status(INITIAL)\r\n\t1. update the status of State to (IN_PROCESS)\r\n\t1. invoke the crawler service to obtain districts for state\r\n\t1. parse/process the districts obtained\r\n\t1. put them in another Queue\r\n\t1. store the districts into HSQLDB\r\n\t1. mark the state as processed (COMPLETED)\r\n\t\t\r\n* **pincode-invoke-route**\r\n\t1. pool the DB( HsqlDb) and get the District with some status(INITIAL)\r\n\t1. update the status of District to (IN_PROCESS)\r\n\t1. invoke the crawler service to obtain areas/cities for the fetched District\r\n\t1. parse/process the areas/cities obtained\r\n\t1. put them in another Queue\r\n\t1. store the area/city into HSQLDB\r\n\t1. mark the district as processed (COMPLETED)\r\n\r\nIn a nutshell there are some routes which invokes a crawl url , the result of which is parsed/processed and then saved into the crawl Database\r\n\r\n## Configuring the application:\r\n\r\n**Scheduling configuration:**\r\n\r\n1. Open camel-routes.xml and change the cron in statement to a suitable time \r\n\t     `quartz://myGroup/myTimerName?cron=30 06 00 03 08 ? 2016`\r\n1. Open the camel-routing-policy.xml and schedule time for\r\n\t1.  districts-invoke-route\r\n\t1.  pincode-route-policy\r\n\t\t\t\r\n## Running the application:\r\n1. mvn clean install\r\n1. run the HSQL Database \r\n1. Go to hsqldb folder\r\n      Windows:  click db_sart.bat\r\n      Unix/Linux:  sh  db_start.sh\r\n1. mvn exec:exec\t  \t\t\r\n      This will execute **com.javatask.Run**\r\n\r\n## Monitoring :\r\n1. Using Jconsole\r\n   Application can be monitored using Jconsole at port 8764 ( port can be changed by changing  the jmx setting in pom.xml)\r\n\r\n\t`<argument>-Dcom.sun.management.jmxremote</argument>`         \r\n\t`<argument>-Dcom.sun.management.jmxremote.authenticate=false</argument>`       \r\n\t`<argument>-Dcom.sun.management.jmxremote.ssl=false</argument>`       \r\n\t`<argument>-Dcom.sun.management.jmxremote.port=8764</argument>`       \r\n\t\r\n  open Jsonsole and add\r\n          `service:jmx:rmi:///jndi/rmi://127.0.0.1:8764/jmxrmi`\r\n\t \t\r\n1. Monitoring HSQL DB\r\n     - Windows Client\r\n\r\n     execute db_client.bat available in hsqldb folder\r\n\t   \t\t\r\n\t   \t\t \t\r\n\t \t\r\n\t\r\n\t \t","name":"web-crawler","tagline":"Crawling  the Web using Apache camel","google":""}